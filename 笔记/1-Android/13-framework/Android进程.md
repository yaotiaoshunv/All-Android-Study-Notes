```
adb shell
ps -ef
```

ps全称process status，为进程状态。

ps 的几个参数如下：

-A	显示所有程序。

-e	此参数的效果和指定"A"参数相同。

-f 　显示UID，PPIP，C，STIME栏位。 



下面看下 **ps -ef** 的输出结果：

**![image-20210305140830234](C:\Users\NJCS\AppData\Roaming\Typora\typora-user-images\image-20210305140830234.png)**

UIP	程序被该 UID 所拥有

PID	进程 ID 

PPID  当前进程的父进程的ID

C 	   CPU使用的资源百分比

STIME 系统启动时间

TTY 	登入者的终端机位置

TIME 	使用掉的 CPU 时间。

CMD 	所下达的指令为何



![image-20210305142329069](C:\Users\NJCS\AppData\Roaming\Typora\typora-user-images\image-20210305142329069.png)

1、可以看到 init进程是开机后第一个启动的进程，zygote进程在init进程之后启动。

2、还可以注意到zygote进程的父进程是init。



下面再看两个APP的进程示例：

![image-20210305144608701](C:\Users\NJCS\AppData\Roaming\Typora\typora-user-images\image-20210305144608701.png)

上面的是我写的demo，其父进程为503，即zygote。

下面的是QQ音乐，其父进程为504，即zygote64。

**这也引出了一个疑问zygote64和zygote的关系是什么？**



**PID越大，进程创建的越晚。**（<u>还不是十分确定</u>）





## 父进程和子进程

# 父进程

在计算机领域，父进程（英语：Parent Process）指已创建一个或多个子进程的进程。

## UNIX

------

在UNIX里，除了进程0（即PID=0的交换进程，*Swapper Process*）以外的所有进程都是由其他进程使用系统调用fork创建的，这里调用fork创建新进程的进程即为父进程，而相对应的为其创建出的进程则为子进程，因而除了进程0以外的进程都只有一个父进程，但一个进程可以有多个子进程。

操作系统内核以进程标识符（*Process Identifier*，即PID）来识别进程。进程0是系统引导时创建的一个特殊进程，在其调用fork创建出一个子进程（即PID=1的进程1，又称init）后，进程0就转为交换进程（有时也被称为空闲进程），而进程1（init进程）就是系统里其他所有进程的祖先。

## 僵尸进程与孤儿进程

------

当一个子进程结束运行（一般是调用exit、运行时发生致命错误或收到终止信号所导致）时，子进程的退出状态（返回值）会回报给操作系统，系统则以SIGCHLD信号将子进程被结束的事件告知父进程，此时子进程的进程控制块（PCB）仍驻留在内存中。一般来说，收到SIGCHLD后，父进程会使用wait系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的PCB；而如若父进程没有这么做的话，子进程的PCB就会一直驻留在内存中，也即成为僵尸进程。

孤儿进程则是指父进程结束后仍在运行的子进程。在类UNIX系统中，孤儿进程一般会被init进程所“收养”，成为init的子进程。

为避免产生僵尸进程，实际应用中一般采取的方式是：

1. 将父进程中对SIGCHLD信号的处理函数设为SIG_IGN（忽略信号）；
2. fork两次并杀死一级子进程，令二级子进程成为孤儿进程而被init所“收养”、清理。

## Linux

在Linux内核中，进程和POSIX线程有着相当微小的区别，父进程的定义也与UNIX不尽相同。Linux有两种父进程，分别称为（形式）父进程与实际父进程，对于一个子进程来说，其父进程是在子进程结束时收取SIGCHLD信号的进程，而实际父进程则是在多线程环境里实际创建该子进程的进程。对于普通进程来说，父进程与实际父进程是同一个进程，但对于一个以进程形式存在的POSIX线程，父进程和实际父进程可能是不一样的。

 

# 子进程

在计算机领域中，**子进程为由另外一个进程（对应称之为父进程）所创建的进程**。子进程继承了父进程的大部分属性，例如文件描述符。

## 产生

------

在Unix中，子进程通常为系统调用`fork`的产物。在此情况下，子进程一开始就是父进程的副本，而在这之后，根据具体需要，子进程可以借助`exec`调用来链式加载另一程序。

## 与父进程的关系

------

一个进程可能下属多个子进程，但最多只能有1个父进程，而若某一进程没有父进程，则可知该进程很可能由内核直接生成。在Unix与类Unix系统中，进程ID为1的进程（即init进程）是在系统引导阶段由内核直接创建的，且不会在系统运行过程中终止执行（可参见Linux启动流程）；而对于其他无父进程的进程，则可能是为在用户空间完成各种后台任务而执行的。

当某一子进程结束、中断或恢复执行时，内核会发送SIGCHLD信号予其父进程。在默认情况下，父进程会以SIG_IGN函数忽略之。

## “孤儿进程”与“僵尸进程”

------

在对应的父进程结束执行后，进程就会变成孤儿进程，但之后会立即由init进程“收养”为其子进程。

某一子进程终止执行后，若其父进程未提前调用`wait`，则内核会持续保留子进程的退出状态等信息，以使父进程可以`wait`获取之。而因为在这种情况下，子进程虽已终止，但仍在消耗系统资源，所以其亦称僵尸进程。`wait`常于SIGCHLD信号的处理函数中调用。

### 解决与预防

在POSIX.1-2001标准规定中，父进程可将SIGCHLD的处理函数设为SIG_IGN（亦为默认设定），或为SIGCHLD设定SA_NOCLDWAIT标记，以使内核可以自动回收已终止的子进程的资源。自Linux 2.6与FreeBSD 5.0起，两种内核皆支持了这两种方式。但是，在忽略SIGCHLD信号的问题上，由于System V与BSD由来已久的差异，若要回收派生出的子进程的资源，调用`wait`仍是最便捷的方式。

